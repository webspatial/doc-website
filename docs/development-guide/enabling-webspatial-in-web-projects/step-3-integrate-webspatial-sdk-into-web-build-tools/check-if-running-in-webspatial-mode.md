---
sidebar_position: 4
---

# Check If Running in WebSpatial Mode

The [previous section](generate-a-webspatial-specific-website) explained that WebSpatial SDK can automatically build two sets of site assets:

- One set targets desktop/mobile platforms and regular browsers and does not include the [WebSpatial SDK](../../../core-concepts/unique-concepts-in-webspatial#webspatial-sdk).
- The other set targets the [WebSpatial App Shell](../../../core-concepts/unique-concepts-in-webspatial#webspatial-sdk) and does include the WebSpatial SDK.

Your own application code may also contain logic that is specific to WebSpatial apps, such as:

- Spatial UI that differs greatly from a normal web UI
- 3D content unique to WebSpatial apps

> Example project: https://github.com/webspatial/sample-techshop
>
> <div className="row">
>   <div className="col col--6">
>     <Image src="/assets/concepts/3-12.png" alt="Non-spatial version" />
>   </div>
>   <div className="col col--6">
>     <Image src="/assets/concepts/3-13.png" alt="Spatial version with transparent background" />
>   </div>
> </div>
> The left image shows the non-spatial UI; the right image shows the spatial UI.

This code shouldn't run or even be included in the build for the desktop/mobile platform and regular browsers.

To achieve this optimization, confidently leverage spatial features and innovate freely, you need a reliable way to know whether the code is running in a WebSpatial app or in a regular website.

## Recommended JS solution {#js-solution}

If your web project includes a Node.js-based server, you first need to decide whether you're using a [single-web-server mode](./generate-a-webspatial-specific-website#single-web-server) or [multi-web-server mode](./generate-a-webspatial-specific-website#multi-web-server).

In multi-web-server mode, the server for WebSpatial sets the [`$XR_ENV`](./generate-a-webspatial-specific-website#dedicated-dev-server) environment variable when it starts, so your server code can just check that variable to know if it's running in the WebSpatial-specific server.

If you're using a single-web-server mode, you'll need to check the User-Agent string in web requests at runtime to identify whether the request is coming from a regular browser or the [WebSpatial App Shell](../../../core-concepts/unique-concepts-in-webspatial#webspatial-sdk).

### WebSpatial-specific UA string {#ua}

For [Packaged WebSpatial Apps](../../../core-concepts/unique-concepts-in-webspatial#webspatial-sdk) on visionOS generated by [WebSpatial Builder](../step-2-add-build-tool-for-packaged-webspatial-apps), the UA string is as follows:

```http {3}
Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7; wv)
AppleWebKit/605.1.15 (KHTML, like Gecko)
WebSpatial/0.1.17
```

For third-party browsers that support WebSpatial apps on visionOS (with built-in WebSpatial App Shell, currently in development), the UA string is as follows:

```http {3}
Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)
AppleWebKit/605.1.15 (KHTML, like Gecko)
WebSpatial/0.1.17 Safari/605.1.15
```

### For client-side JS {#client-js-solution}

In client-side JS, you can either check the [UA string](#ua) at runtime to see if the code is running in a WebSpatial app, or inject the [`$XR_ENV`](./generate-a-webspatial-specific-website#dedicated-dev-server) environment variable during the build so it's available as a constant in your client-side code.

:::info
In Vite you can access it directly with `import.meta.env.XR_ENV`, no extra config needed.
:::

You can also inject other constants derived from **`$XR_ENV`**.

For example, if you use client-side routing, it is best to inject a **`__XR_ENV_BASE__`** constant:

```js title="vite.config.js" {3-7}
// https://vite.dev/config/
export default defineConfig({
  define: {
    __XR_ENV_BASE__: process.env.XR_ENV
      ? JSON.stringify(`/webspatial/${process.env.XR_ENV}`)
      : undefined,
  },
  plugins: [
```

:::info
The [WebSpatial's plugins for web build tools](./add-optimizations-and-defaults-to-web-build-tools) automatically inject **`__XR_ENV_BASE__`**, so you can skip the manual config above.
:::

See the usage example in the **[Quick Example](../../../quick-example/)**.

```jsx
<Router basename={__XR_ENV_BASE__}>
```

```jsx
 <button
   onClick={() => {
     window.open(`${__XR_ENV_BASE__}/second-page`, "secondScene");
   }}>
```

## Recommended CSS solution {#css-solution}

### A future standardizable approach

:::warning
This API is not yet supported by WebSpatial SDK.
:::

<details>
<summary>Use a media query in CSS to match the <code>space</code> color scheme:</summary>

On spatial-computing platforms the background environment color is unpredictable and changes with viewpoint and location, so the classic light/dark mode does not apply.

The WebSpatial API introduces a new color scheme called **`space`**, which is recognized only in WebSpatial apps. You can use it to target WebSpatial-specific CSS rules.

```css
@media (prefers-color-scheme: space) {
```

</details>

### A practical solution for now

Configure your web build tool so that **`$XR_ENV`** is injected into HTML.

E.g. with [Vite](./add-optimizations-and-defaults-to-web-build-tools):

1. Install the **vite-plugin-html** plugin.

```bash npm2yarn
npm install -D vite-plugin-html
```

2. Update `vite.config.js`.

```js
// diff-add
import { createHtmlPlugin } from "vite-plugin-html";

// https://vite.dev/config/
export default defineConfig({
  plugins: [
// diff-add
    createHtmlPlugin({
// diff-add
      inject: {
// diff-add
        data: {
// diff-add
          XR_ENV: process.env.XR_ENV,
// diff-add
        },
// diff-add
      },
// diff-add
    }),
```

3. Modify the HTML template and add a class name that is only present when **`XR_ENV`** indicates spatial mode, for example on `<html>`.

<!-- prettier-ignore-start -->
```html
// diff-add
<%- XR_ENV === 'avp' ? `
// diff-add
<html lang="en" class="is-spatial">
  // diff-add
  ` : `
  <html lang="en">
    // diff-add
    ` %>
```
<!-- prettier-ignore-end -->

In your CSS, wrap any WebSpatial-specific rules under `html.is-spatial`.

```css {1}
html.is-spatial {
  .my-card {
```
